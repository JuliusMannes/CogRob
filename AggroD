
import java.io.IOException;

import lejos.hardware.motor.Motor;
import lejos.hardware.port.SensorPort;
import lejos.hardware.sensor.SensorMode;
import lejos.robotics.SampleProvider;
import lejos.hardware.sensor.NXTUltrasonicSensor;
import lejos.robotics.subsumption.Behavior;


public class AggroD implements Behavior {
	NXTUltrasonicSensor ls = null;
	NXTUltrasonicSensor rs = null;
	private boolean suppressed = false; 
	private int SampleSize = 5;
	private float MinDis = 10.0f; //to be adjusted
	private float SpeedWeight = 2000.0f;

public AggroD() { 
// right sensorports to be added
	ls = new NXTUltrasonicSensor(SensorPort.S3);
	rs = new NXTUltrasonicSensor(SensorPort.S2);
}



@Override
public boolean takeControl() {
	//if light source above treshold - take action
	float Left = detectDis_left();
	float Right = detectDis_right();
	System.out.println("Left: "+Left+"; Right:"+Right);
	return (Right < MinDis || Left < MinDis );
}

//if it detects Object on the right it turns right, vice versa with left, if object in center both motors start
@Override
public void action() {
	boolean Driving = true;
	 while( !suppressed && Driving) {
		Driving = false;
		//Right motor (A)
		float LeftDetection = detectDis_left();
		if (LeftDetection < MinDis) {
			Motor.D.forward();
			Motor.D.setSpeed(Math.max(0, 2 * SpeedWeight));
			Driving = true;
		} else {
			Motor.D.stop(true);
		}
		//Left motor (D)
		float RightDetection = detectLight_right();
		if (RightDetection < MinDis) {
			Motor.A.forward();
			Motor.A.setSpeed(Math.max(0, 2 * SpeedWeight));
			Driving = true;
		} else {
			Motor.A.stop(true);
		}
	 }
	 Thread.yield();
	 
	 //Clean up
	 Motor.A.stop(); 
	 Motor.D.stop();
}

@Override
public void suppress() {
	suppressed = true;
}
	 
private float detectDis_right() {
	SampleProvider Provider_r = rs.getDistanceMode();
	float Sample[] = new float[SampleSize];
	Provider_r.fetchSample(Sample,0);
	
	float Total = 0;
	for(int i=0; i<SampleSize; i++) {
		Total += Sample[i];
	}
	Total /= SampleSize;
	
	return Total;
}
private float detectDis_left() {
	SampleProvider Provider_l = ls.getDistanceMode();
	float Sample[] = new float[SampleSize];
	Provider_l.fetchSample(Sample,0);
	
	float Total = 0;
	for(int i=0; i<SampleSize; i++) {
		Total += Sample[i];
	}
	Total /= SampleSize;
	
	return Total;
}

}
